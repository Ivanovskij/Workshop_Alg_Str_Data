/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package src.java.chapter3;

import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;


/**
 *
 * @author IOAdmin
 */
class InsertArr {

    private long[] arr;
    private int nElems;

    public InsertArr(int maxElem) {
        arr = new long[maxElem];
        nElems = 0;
    }

    //--------------------------------------------------------
    public void insert(long value) {
        arr[nElems] = value;
        nElems++;
    }

    //--------------------------------------------------------
    /**
     * Предпологается, что слева есть частичная сортировка эл-тов Нужно
     * выбрать(пометить) следующицй эл-т(next), сразу после левого края
     * частичной сортировки Пойти в левую часть и сравнивать next с уже частично
     * отсортированными элементами Поставить next в нужное место уже частично
     * отсортированных эл-тов При этом передвигая больший эл-т вправо и
     * сдвигаемся к началу левой части Если эл-ты справа закончились, то
     * Остановка!!!
     *
     * //------------------------------ 
     * for (out) - outer border Этот алгоритм
     * хорошо прорешать на листке Чтобы разобраться как работает
     */
    public void insertSort() {
        long next;
        int out, in;

        // начало с out = 1, предпологается что это 
        // частично отсортированная часть (нулевой эл-т)
        for (out = 1; out < nElems; out++) {                    // Пока есть эл-ты в правой части
            in = out;                                           // Запоминаем конец левой части чтобы сравнивать с next 
            next = arr[out];                                    // выьираем(помечаем) эл-т сразу после левой части
            // пока не достигнуто начало левой части
            // сравниваем с next все эл-ты левой части
            while (in > 0 && arr[in - 1] >= next) {
                arr[in] = arr[in - 1];                          // сдвигаем больший эл-т вправо
                in--;                                           // сдвигаемся к началу левой части
            }
            arr[in] = next;                                     // делаем вставку
        }
    }
    
    
    //--------------------------------------------------------
    /*
        3.5. Измените метод insertionSort() в программе insertSort.java (листинг 3.3),
        чтобы он подсчитывал количество копирований и сравнений в ходе сортировки,
        а затем выводил полученные результаты. Для подсчета сравнений необходимо раз-
        бить надвое сложное условие во внутреннем цикле while . Используйте программу
        для измерения количества копирований и сравнения для разных объемов данных,
        отсортированных в обратном порядке. Подтверждают ли результаты теоретическую
        сложность O(N^2)? Проделайте то же самое для почти отсортированных данных
        (в которых только несколько элементов находятся не на своих местах). Какие выво-
        ды можно сделать об эффективности этого алгоритма для почти отсортированных
        данных?
    */
    public void counting_insertSort() {
        int out, in;
        long next;
        long count_copies = 0;
        long count_comparations = 0;

        for (out = 1; out < nElems; out++) {                    
            in = out;                                           
            next = arr[out];                                   
            while (in > 0 && arr[in - 1] >= next) {
                arr[in] = arr[in - 1];                         
                in--;
                count_comparations += 2;    // так как два сравнения произошло в while(in > 0 && arr[in - 1] >= next)
                count_copies++;           
            }
            // так как если while(false) 
            // то внутри мы не прибавим эти два сравнения
            // но они произошли
            count_comparations += 2;        
            arr[in] = next;             
            count_copies++;                 // строка выше, тоже копирует эл-т
        }
        
        System.out.println("Count comparations = " + count_comparations);
        System.out.println("Count copies = " + count_copies);
    }
    
    
    //--------------------------------------------------------
    /*
        3.6. Существует один интересный способ удаления дубликатов из массива. Со-
        ртировка методом вставки использует алгоритм с вложенными циклами, который
        сравнивает каждый элемент массива с каждым другим элементом. Если вы хотите
        удалить дубликаты, это одно из возможных решений (также см. упражнение 2.6
        в главе 2). Измените метод insertionSort() в программе insertSort.java , чтобы он
        удалял дубликаты в ходе сортировки. Например, при обнаружении дубликата мож-
        но заменить один из экземпляров ключевым значением, которое заведомо меньше
        ключей других элементов (скажем, –1, если все нормальные ключи положитель-
        ны). Затем обычный алгоритм сортировки методом вставки, рассматривающий
        новый ключ наравне со всеми остальными, размещает его в элементе с индексом 0.
        В дальнейшем он будет игнорироваться алгоритмом. Следующий дубликат разме-
        щается в ячейке с индексом 1 и т. д. После завершения сортировки все удаленные
        дубликаты (теперь представленные ключом –1) будут располагаться в начале мас-
        сива. Остается лишь сдвинуть недублированные элементы, чтобы они начинались
        с индекса 0, и изменить размеры массива.
    */
    // Преполагается что на вход идет сортированный массив
    public void noDups3_6() {
        int out, in;
        long next;
        long null_key = -1;                                             // если дубль, то заменяем на -1(null)

        // выполняем стандартную сортировку вставками
        for (out = 1; out < nElems; out++) {                    
            in = out;                                           
            next = arr[out];                                   
            while (in > 0 && arr[in - 1] >= next) {
                if (next == arr[in - 1]) {                              // если нашли дубль(если эл-т в левой части дубль)
                    // если эл-т в левой части уже (-1)null
                    // то есть предполагается, что в левой части уже все эл-ты равны -1
                    if (null_key == arr[in - 1]) {                   
                        // выходим, так как нет смысла двигаться до самого конца
                        // так как там уже все эл-ты равны -1
                        break;                                          
                    }
                    // заменяем эл-т -1(null) на границе
                    // чтобы он сортировкой ушел в начало левой части
                    arr[out] = null_key;                                 
                    next = null_key;                                    // -1(null), чтобы сортировался в начало левой части
                    continue;                                           // продолжаем сортировку с конца границы левой части out
                }
   
                arr[in] = arr[in - 1];                                  
                in--;         
            }  
            arr[in] = next;      
        }

        //-------------- удаление 1, работает медленней ----------------------
//        while (arr[0] == null_key) {                                    // пока на первой позиции -1(null)
//            // своего рода костыль
//            // чтобы ниже в цикле не выбросило исключение на arrayindexoutofbounds exception
//            if (nElems == 1 && arr[nElems] == null_key) {               // если только один эл-т и он равен -1(null)
//                arr = null;                                             // то удаляем его
//                nElems--;
//                break;                                                  // выходим
//            }
//            // смещаем эл-ты
//            for (int i = 0; i < nElems - 1; i++) {
//                arr[i] = arr[i + 1];
//            }
//            nElems--;
//        }   

        //-------------- удаление 2, работает гораздо быстрее, так как меньше копирований ----------------------
        int count_null_key = 0;                                               // кол-во эл-тов в массиве -1(null)
        int newIndex = 0;                                                     // новый индекс для эл-тов без дублей
        // пока мы не превысили кол-во эл-тов в массиве
        // и пока у нас значения -1(null)
        // подсчитываем кол-во -1(null)
        while(count_null_key < nElems && arr[count_null_key] == -1) {
            count_null_key++;
        }
        // удаляем
        for (int j = count_null_key; j < nElems; j++) {
            arr[newIndex] = arr[j];                                         // начинаем с нуля
            newIndex++;                                                     // и прибавляем новые индексы
        }
        nElems -= count_null_key;                                           // уменьшаем размер массива, на кол-во дублей
        
        // своего рода тоже костыль
        // это для того, чтобы удалить единственный эл-т
        // который будет равен -1(null)
        if (newIndex == 0) {
            arr = null;
        }
    }
    

    //--------------------------------------------------------
    /*
        3.2. Добавьте в класс ArrayIns программы insertSort.java (листинг 3.3) метод
        с именем median() , возвращающий медиану массива. (Напомним, что в группе чисел
        половина меньше медианы, а другая половина больше.) Найдите простое решение
        этой задачи.
    
        Медиана – это «середина». Для определения медианы,  
        необходимо отсортировать массив значений в порядке их возрастания, 
        и выбирать средний элемент отсортированного массива. 
        Заметим, что если массив содержит четное число элементов, 
        медиана вычисляется как среднее значение двух элементов в середине массива.
    */
    public long median() {
        int median = (nElems - 1) / 2;
        if ((nElems % 2) != 0) {
            return arr[median];
        } else {
            return ((arr[median] + (arr[median] + 1)) / 2);
        }
    }
    
    
    //--------------------------------------------------------
    /*
        3.3. Добавьте в программу insertSort.java (листинг 3.3) метод noDups() , который
        удаляет дубликаты из ранее отсортированного массива без нарушения порядка
        элементов. (Используйте метод insertionSort() для сортировки данных или просто
        вставьте данные в порядке сортировки в main(). Нетрудно представить себе схему,
        в которой все элементы от позиции обнаружения дубликата до конца массива сдви-
        гаются на одну позицию, но это замедлит работу алгоритма до времени O(N^2) —
        по крайней мере при большом количестве дубликатов. Проследите за тем, чтобы
        в вашем алгоритме ни один элемент не перемещался более одного раза независи-
        мо от количества дубликатов — это обеспечит выполнение алгоритма за время O(N).
    */
    // Преполагается что на вход идет сортированный массив
    // НАВЕРНО Я НЕ ПРАВИЛЬНО СДЕЛАЛ КАК НУЖНО В ЗАДАНИИ, НО РАБОТАЕТ ОЧЕНЬ БЫСТРО
    // ВОЗМОЖНО O(n*logn)
    public void noDups3_3() { 
        // временный массив для не дублированных эл-тов
        long[] tmpArr = new long[nElems];
        
        int elem = 0;                                   // эл-т в старом массиве
        int newIndex = 0;                               // индексация для временного массива
        while (elem < nElems - 1) {                     // двигаемся до позиции -1 в старом массиве
            // так как массив отсортирован, то мы
            // проверяем если эл-т не равен следующему
            if (arr[elem] != arr[elem + 1]) {       
                tmpArr[newIndex] = arr[elem];           // заносим его в массив, т.е. избавляемся от дублей
                newIndex++;
            }
            elem++;                                     // просматриваем следующий эл-т
        }
        // своего рода костыль
        // так как мы двигались в цикле до nElems - 1
        // нам нужно проверить последний эл-т
        // так как мы в цикле выше его не просматривали
        if (tmpArr[newIndex] != arr[elem]) {
            tmpArr[newIndex] = arr[elem];
            newIndex++;
        }
        nElems = newIndex;                              // устанавливаем новую размерность
        
        System.arraycopy(tmpArr, 0, arr, 0, nElems);    // копируем в старый массив временный
    }

    //--------------------------------------------------------
    public int size() {
        return nElems;
    }

    //--------------------------------------------------------
    public void display() {
        for (int i = 0; i < nElems; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println("");
    }

}

/**
 * **********************************************************************
 */
/**
 * **********************************************************************
 */
/**
 * **********************************************************************
 */
class InsertSortApp {

    public static void main(String[] args) {
        int maxElem = 150000;
//        int maxElem = 8;
        InsertArr insertArr = new InsertArr(maxElem);
        
//        insertArr.insert(1);
//        insertArr.insert(0);
//        insertArr.insert(1);
//        insertArr.insert(3);
//        insertArr.insert(4);
//        insertArr.insert(1);
//        insertArr.insert(5);
//        insertArr.insert(6);
        
        insertArr.display();

        for (int i = maxElem; i > 0; i--) {
            long r = ThreadLocalRandom.current().nextLong(10,100);
            insertArr.insert(r);
        }

        double start = System.nanoTime();
        System.out.println("InsertSort:");
        insertArr.insertSort();
        System.out.println("Time: " + ((System.nanoTime() - start) / 1000000000));

//        double start = System.nanoTime();
//        System.out.println("InsertSort:");
//        insertArr.counting_insertSort();
//        System.out.println("Time: " + ((System.nanoTime() - start) / 1000000000));

        insertArr.display();
        
        System.out.println("Median = " + insertArr.median());
        
        // удаляние дублей
        start = System.nanoTime();
        System.out.println("NoDups3_3:");
        insertArr.noDups3_3();
        System.out.println("Time: " + ((System.nanoTime() - start) / 1000000000));
        insertArr.display();

        // удаляние дублей
//        start = System.nanoTime();
//        System.out.println("NoDups3_6:");
//        insertArr.noDups3_6();
//        System.out.println("Time: " + ((System.nanoTime() - start) / 1000000000));
//        insertArr.display();
        
    }

}
